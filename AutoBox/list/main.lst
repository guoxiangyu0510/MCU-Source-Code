C51 COMPILER V9.00   MAIN                                                                  08/31/2016 20:59:53 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\obj\main.obj
COMPILER INVOKED BY: D:\Program Files\KeilC51V9.00\C51\BIN\C51.EXE ..\user\main.c BROWSE INCDIR(..\include) DEBUG OBJECT
                    -EXTEND PRINT(..\list\main.lst) OBJECT(..\obj\main.obj)

line level    source

   1          /*
   2                  待完成功能
   3                  1.产品出厂初始设定：产品关机键连续按5次启动出厂设置
   4                                                          即按顺序学习小盒的关闭和打开遥控命令
   5                                                          （此功能有可能会无意中混乱按键，为防止此情况发生，
   6                                                            加入recover Pin有硬件操作完成）
   7                  2.出现阻转故障后的处理
   8                  3.添加看门狗
   9                  4.增加AD采样滤波器
  10                  5.考虑添加复位按键
  11                  6.软启动功能
  12          */
  13          
  14          #include <STC15.h>
  15          #include <string.h>
  16          #include <intrins.h>
  17          #include "timer0.h"
  18          #include "typeDef.h"
  19          #include "motor.h"
  20          #include "math.h"
  21          #include "eeprom.h"
  22          
  23          #define FOSC    12000000L
  24          #define T100Hz  (FOSC / 12 / 100)
  25          #define CCP_S0 0x10                 //P_SW1.4
  26          #define CCP_S1 0x20                 //P_SW1.5
  27          
  28          #define IR_HEADER_TIME_Y 9000           //前导码有38K调制波时间 9ms
  29          #define IR_HEADER_TIME_N 4500           //前导码无38K调制波时间 4.5ms
  30          #define IR_DATA_TIME_Y   560            //数据码有38K调制波固定时间     0.56ms
  31          #define IR_LOGIC_1_CYCLE 2250           //逻辑1时数据码周期         2.25ms
  32          #define IR_LOGIC_0_CYCLE 1120           //逻辑0时数据码周期             1.12ms
  33          #define this_recv_usr_code IR_RecvBuf[0]
  34          #define this_recv_cmd_code IR_RecvBuf[2]
  35          #define IR_IAP_INFO_ADDR 0x0400
  36          
  37          #define SIG_STOP 0
  38          #define SIG_BEGIN 1
  39          
  40          //*********************************
  41          //About Box status
  42          // x     x       x        x      x       x              xx
  43          //活动 完成     错误  0  0   0   1:打开 2:关闭
  44          #define STAT_BOX_OPENING        0x81
  45          #define STAT_BOX_OPENED         0x41
  46          #define STAT_BOX_CLOSING        0x82
  47          #define STAT_BOX_CLOSED         0x42
  48          #define STAT_BOX_OPEN_ERROR     0x21
  49          #define STAT_BOX_CLOSE_ERROR 0x22
  50          #define STAT_BOX_STOP_IN_OP     0x01
  51          #define STAT_BOX_STOP_IN_CL     0x02
  52          
  53          #define BOX_IS_ACTIVE() ((Box_status&0x80) != 0)
  54          #define BOX_IS_FINISH() ((Box_status&0x40) != 0)
C51 COMPILER V9.00   MAIN                                                                  08/31/2016 20:59:53 PAGE 2   

  55          
  56          #define ASSERT(RESULT,FLAG)                                                                                     \
  57                                  if(RESULT == -1 )                                                                                       \
  58                                  {                                                                                                                       \
  59                                          debug_uart_print_string_int(FLAG);                                              \
  60                                          while(IR_wait_status(1, SIG_STOP, 6000, 6000)!=-1);             \
  61                                          IE0=0;EX0 = 1;                                                                                  \
  62                                          return;                                                                                                 \
  63                                  }
  64          
  65          #define _DEBUG_
  66          
  67          sbit IR_Pin = P3^2;
  68          
  69          u8 IR_RecvBuf[4],IR_RecvFlag,set_times,set_index;
  70          
  71          u8 IR_usr_code,IR_cmd_code;
  72          
  73          u8 Box_status;
  74          
  75          #define AD_HIST_SIZE 8
  76          u8 xdata AD_hist_data[AD_HIST_SIZE];
  77          u8 xdata AD_sample_pos;
  78          u8 xdata AD_data_max,AD_data_min;
  79          u16 xdata AD_data_sum;
  80          u8 xdata AD_this_data;
  81          u8 xdata AD_filter_out;
  82          
  83          struct motor myMotor,*pMyMotor;
  84          
  85          struct IR_info_t
  86          {       
  87                  u8 user_code;   //用户码                
  88                  u8 set_code;    //设置键码      
  89                  u8 open_code;   //打开键码
  90                  u8 close_code;  //关闭键码
  91                  u8 enable;              //IR信息有效标记
  92          }IR_info;
  93          
  94          u8 xdata cnt, sys_clk_100HZ_flag;
  95          u16 xdata value;
  96          
  97          
  98          
  99          #if defined (_DEBUG_)
 100          #define debug_uart_print_string(str) uart_print_string(str)
 101          #define debug_uart_print_value(val)  uart_print_value(val)
 102          #define debug_uart_print_hex(val)        uart_print_hex(val)
 103          #define debug_uart_print_string_int(str) uart_print_string_int(str)
 104          void usart_init(void)
 105          {
 106   1              SCON = 0x50;            //8位数据,可变波特率
 107   1              AUXR |= 0x01;           //串口1选择定时器2为波特率发生器
 108   1              AUXR |= 0x04;           //定时器2时钟为Fosc,即1T
 109   1              T2L = 0xC7;                     //设定定时初值
 110   1              T2H = 0xFE;                     //设定定时初值
 111   1              AUXR |= 0x10;           //启动定时器2   
 112   1      }
 113          char putchar (char c)  
 114          {
 115   1              SBUF = c;
 116   1              while (!TI);
C51 COMPILER V9.00   MAIN                                                                  08/31/2016 20:59:53 PAGE 3   

 117   1              TI = 0;
 118   1              return c;
 119   1      }
 120          void uart_print_string_int(char *str)
 121          {
 122   1              while(*str !='\0')
 123   1              {
 124   2                      putchar(*str);
 125   2                      str++;
 126   2              }
 127   1      }
 128          void uart_print_string(char *str)
 129          {
 130   1              char ch;
 131   1      
 132   1              ch = *str;
 133   1              while(ch != '\0')
 134   1              {               
 135   2                      if(ch == '\\')
 136   2                      {
 137   3                              switch(*(str+1))
 138   3                              {
 139   4                                      case 'n': ch='\n'; str ++; break;
 140   4                                      case 'r': ch='\r'; str ++; break;
 141   4                                      case 't': ch='\t'; str ++; break;
 142   4                              }       
 143   3                      }
 144   2                      putchar(ch);
 145   2                      str ++;
 146   2                      ch = *str;
 147   2              }
 148   1      }
 149          void uart_print_value(int value)
 150          {
 151   1              int base;
 152   1              
 153   1              base = 10000;
 154   1              if(value < 0)
 155   1              {
 156   2                      value = abs(value);
 157   2                      putchar('-');
 158   2              }
 159   1              while(base != 0)
 160   1              {               
 161   2                      putchar('0'+value/base);
 162   2                      value %= base;
 163   2                      base/=10;
 164   2              }
 165   1      }
 166          char hexTab[]="01234567890ABCDEF";
 167          void uart_print_hex(u8 value)
 168          {
 169   1              putchar(hexTab[value>>4]);
 170   1              putchar(hexTab[value&0x0f]);            
 171   1      }
 172          #else
                      #define debug_uart_print_string(str) 
                      #define debug_uart_print_value(val) 
                      #define debug_uart_print_string_int(str)        
              #endif
 177          
 178          /*=============================*/
C51 COMPILER V9.00   MAIN                                                                  08/31/2016 20:59:53 PAGE 4   

 179          /*       看门狗初始化（打开状态）
 180          /*=============================*/
 181          #define feed_dog() (WDT_CONTR|=0x10)
 182          #define watchDog_disable() (WDT_CONTR&=~0x20)
 183          #define watchDog_enable()  (WDT_CONTR|=0x20)
 184          void watchDog_init(void)
 185          {
 186   1              //看门狗定时器溢出时间计算公式: (12 * 32768 * PS) / FOSC (秒)
 187   1              //12M : 1.0485s
 188   1              WDT_CONTR = 0x04;                        
 189   1              watchDog_enable();      
 190   1      }
 191          /*=============================*/
 192          /*                软件延时
 193          /*=============================*/
 194          void delayMs(u8 time)
 195          {
 196   1              u16 timeUs;
 197   1      
 198   1              timeUs = (time>=65)? 65000:(time*1000);
 199   1              timer0_clear();
 200   1              timer0_start();
 201   1              while(timer0_read() < timeUs);
 202   1              timer0_stop();
 203   1      }
 204          void delayS(unsigned char time)
 205          {
 206   1              u16 temp;
 207   1      
 208   1              feed_dog();      //喂狗
 209   1              temp = time*20;
 210   1              for(;temp>0;temp--)
 211   1              {
 212   2                      delayMs(50);
 213   2                      feed_dog();      //喂狗
 214   2              }
 215   1      }
 216          
 217          /*=============================*/
 218          /*                系统时钟初始化
 219          /*=============================*/
 220          void system_clk_init(void)
 221          {
 222   1              ACC = P_SW1;
 223   1          ACC &= ~(CCP_S0 | CCP_S1);      //CCP_S0=0 CCP_S1=0
 224   1          P_SW1 = ACC;                    //(P1.2/ECI, P1.1/CCP0, P1.0/CCP1, P3.7/CCP2)
 225   1          
 226   1      //  ACC = P_SW1;
 227   1      //  ACC &= ~(CCP_S0 | CCP_S1);      //CCP_S0=1 CCP_S1=0
 228   1      //  ACC |= CCP_S0;                  //(P3.4/ECI_2, P3.5/CCP0_2, P3.6/CCP1_2, P3.7/CCP2_2)
 229   1      //  P_SW1 = ACC;  
 230   1      //  
 231   1      //  ACC = P_SW1;
 232   1      //  ACC &= ~(CCP_S0 | CCP_S1);      //CCP_S0=0 CCP_S1=1
 233   1      //  ACC |= CCP_S1;                  //(P2.4/ECI_3, P2.5/CCP0_3, P2.6/CCP1_3, P2.7/CCP2_3)
 234   1      //  P_SW1 = ACC;  
 235   1      
 236   1          CCON = 0;                       //初始化PCA控制寄存器
 237   1                                          //PCA定时器停止
 238   1                                          //清除CF标志
 239   1                                          //清除模块中断标志
 240   1          CL = 0;                         //复位PCA寄存器
C51 COMPILER V9.00   MAIN                                                                  08/31/2016 20:59:53 PAGE 5   

 241   1          CH = 0;
 242   1          CMOD = 0x00;                    //设置PCA时钟源
 243   1                                          //禁止PCA定时器溢出中断
 244   1          value = T100Hz;
 245   1          CCAP0L = value;
 246   1          CCAP0H = value >> 8;            //初始化PCA模块0
 247   1          value += T100Hz;
 248   1          CCAPM0 = 0x49;                  //PCA模块0为16位定时器模式
 249   1      
 250   1          CR = 1;                         //PCA定时器开始工作
 251   1              sys_clk_100HZ_flag = 0;
 252   1          cnt = 0;
 253   1      }
 254          
 255          /*=============================*/
 256          /*        红外信息恢复出厂状态
 257          /*=============================*/
 258          s8 IR_recovery_factory_mode(struct IR_info_t *info)
 259          {
 260   1              if(info->enable != 0xff)
 261   1              {
 262   2                      IapEraseSector(IR_IAP_INFO_ADDR);
 263   2                      info->user_code = 0xff;
 264   2                      info->set_code = 0xff;
 265   2                      info->open_code = 0xff;
 266   2                      info->close_code = 0xff;
 267   2                      info->enable = 0xff;
 268   2              }
 269   1              debug_uart_print_string_int("IR is recovery factory mode\r\n");
 270   1      
 271   1              return 0;
 272   1      }
 273          
 274          /*=============================*/
 275          /*      设置红外信息（保存到eeprom）
 276          /*=============================*/
 277          s8 IR_remote_info_set(struct IR_info_t *info)
 278          {
 279   1              IapEraseSector(IR_IAP_INFO_ADDR);
 280   1              IapProgramByte(IR_IAP_INFO_ADDR,0x55);
 281   1              IapProgramByte(IR_IAP_INFO_ADDR+1,info->user_code);
 282   1              IapProgramByte(IR_IAP_INFO_ADDR+2,info->set_code);
 283   1              IapProgramByte(IR_IAP_INFO_ADDR+3,info->open_code);
 284   1              IapProgramByte(IR_IAP_INFO_ADDR+4,info->close_code);
 285   1              info->enable = 0x00;
 286   1              debug_uart_print_string_int("IR remote info set ok\r\n");
 287   1      
 288   1              return 0;               
 289   1      }
 290          
 291          /*=============================*/
 292          /*        从eeprom中读取IR信息
 293          /*=============================*/
 294          s8 IR_info_read_from_eeprom(struct IR_info_t *info)
 295          {
 296   1              if(IapReadByte(IR_IAP_INFO_ADDR) == 0x55)
 297   1              {
 298   2                      info->user_code = IapReadByte(IR_IAP_INFO_ADDR+1);
 299   2                      info->set_code  = IapReadByte(IR_IAP_INFO_ADDR+2);
 300   2                      info->open_code  = IapReadByte(IR_IAP_INFO_ADDR+3);
 301   2                      info->close_code  = IapReadByte(IR_IAP_INFO_ADDR+4);
 302   2                      info->enable = 0x00;
C51 COMPILER V9.00   MAIN                                                                  08/31/2016 20:59:53 PAGE 6   

 303   2                      debug_uart_print_string_int("IR remote info read ok\r\n");
 304   2      
 305   2                      return 0;
 306   2              } 
 307   1              info->enable = 0xFF;
 308   1              debug_uart_print_string_int("IR remote info is null\r\n");
 309   1      
 310   1              debug_uart_print_string_int("Please press shutdown code:\r\n");
 311   1              return -1;
 312   1      }
 313          
 314          /*=============================*/
 315          /*                红外控制初始化
 316          /*=============================*/
 317          void IR_init(void)
 318          {
 319   1              P32 = 1;
 320   1              //下降沿触发
 321   1              IT0 = 1;
 322   1              memset(IR_RecvBuf, 0, sizeof(IR_RecvBuf));
 323   1              IR_RecvFlag = 0;
 324   1              set_times = 0;
 325   1              set_index = 0;
 326   1              IR_info_read_from_eeprom(&IR_info);
 327   1              EX0 = 1;        
 328   1      }
 329          
 330          /*=============================*/
 331          /*                限位开关初始化
 332          /*=============================*/
 333          void limit_switch_init(void)
 334          {
 335   1              P33 = P36 = 1;
 336   1              INT_CLKO |= 0x10;
 337   1              IT1 = 1;
 338   1              EX1 = 1;
 339   1      }
 340          
 341          /*=============================*/
 342          /*              平均值滤波器初始化
 343          /*=============================*/
 344          void filter_init(void)
 345          {
 346   1              memset(AD_hist_data,0,sizeof(AD_hist_data));
 347   1              AD_sample_pos = 0;
 348   1              AD_data_max = 0;
 349   1              AD_data_min = 0;
 350   1              AD_data_sum = 0;
 351   1              AD_this_data = 0;
 352   1              AD_filter_out = 0;
 353   1      }
 354          
 355          /*=============================*/
 356          /*        MCU进入掉电模式（睡眠）
 357          /*=============================*/
 358          void MCU_sleep_mode(void)
 359          {       
 360   1              //进入掉电模式之前确保外部中断为开启状态
 361   1              IE0 = 0;
 362   1              EX0 = 1;
 363   1              EA = 1;
 364   1              //MCU进入掉电模式
C51 COMPILER V9.00   MAIN                                                                  08/31/2016 20:59:53 PAGE 7   

 365   1              PCON = 0x02;            
 366   1              //掉电模式被唤醒后,首先执行此语句,然后再进入中断服务程序
 367   1              _nop_();                
 368   1          _nop_();
 369   1              _nop_();
 370   1              _nop_();
 371   1      }
 372          
 373          /*=============================*/
 374          /*                打开盒子
 375          /*=============================*/
 376          void box_open_begin(void)
 377          {
 378   1              if(Box_status != STAT_BOX_OPENED && Box_status != STAT_BOX_OPENING)// && Box_status !=STAT_BOX_OPEN_ERROR
             -)
 379   1              {
 380   2                      Motor_set_status(pMyMotor,MOTOR_FORWORD);
 381   2                      Box_status = STAT_BOX_OPENING;          
 382   2                      debug_uart_print_string_int("Box is openning ...\r\n");                 
 383   2              }
 384   1              else
 385   1              {
 386   2                      debug_uart_print_string_int("Box_open_finish\r\n");
 387   2              }               
 388   1      }
 389          void box_open_finish(void)
 390          {
 391   1              if(Box_status != STAT_BOX_OPENED)
 392   1              {
 393   2                      Motor_set_status(pMyMotor,MOTOR_STOP);
 394   2                      Box_status = STAT_BOX_OPENED;
 395   2              }       
 396   1              debug_uart_print_string_int("Box_open_finish\r\n");             
 397   1      }
 398          
 399          void box_close_begin(void)
 400          {
 401   1              if(Box_status != STAT_BOX_CLOSED && Box_status != STAT_BOX_CLOSING)// && Box_status !=STAT_BOX_CLOSE_ERRO
             -R)
 402   1              {
 403   2                      Motor_set_status(pMyMotor,MOTOR_REVERSAL);      
 404   2                      Box_status = STAT_BOX_CLOSING;
 405   2                      debug_uart_print_string_int("Box is closing ...\r\n");          
 406   2              } 
 407   1              else
 408   1              {
 409   2                      debug_uart_print_string_int("Box close finish\r\n");    
 410   2              }       
 411   1      }
 412          void box_close_finish(void)
 413          {
 414   1              if(Box_status != STAT_BOX_CLOSED)
 415   1              {
 416   2                      Motor_set_status(pMyMotor,MOTOR_STOP); 
 417   2                      Box_status = STAT_BOX_CLOSED;
 418   2              }       
 419   1              debug_uart_print_string_int("Box close finish\r\n");
 420   1      }
 421          
 422          void box_stop_in_activity()
 423          {
 424   1              if(BOX_IS_ACTIVE())
C51 COMPILER V9.00   MAIN                                                                  08/31/2016 20:59:53 PAGE 8   

 425   1              {
 426   2                      Motor_set_status(pMyMotor,MOTOR_STOP);
 427   2                      if( !BOX_IS_FINISH() )
 428   2                      {
 429   3                              if(Box_status == STAT_BOX_OPENING)
 430   3                              {
 431   4                                      Box_status = STAT_BOX_STOP_IN_OP;
 432   4                              }
 433   3                              else
 434   3                              {
 435   4                                      Box_status = STAT_BOX_STOP_IN_CL;       
 436   4                              }       
 437   3                      }
 438   2                      debug_uart_print_string_int("Box stop in activity\r\n");
 439   2              }       
 440   1              else
 441   1              {
 442   2                      debug_uart_print_string_int("Box always is stoped!\r\n");
 443   2              }
 444   1      }
 445          /*=============================*/
 446          /*                盒子初始状态设置
 447          /*=============================*/
 448          void box_status_init(void)
 449          {
 450   1              pMyMotor = &myMotor;
 451   1              Motor_init(pMyMotor);
 452   1              Box_status = STAT_BOX_STOP_IN_OP;
 453   1              box_stop_in_activity(); 
 454   1      }
 455          
 456          /*=============================*/
 457          /*                板级初始化
 458          /*=============================*/
 459          void board_init(void)
 460          {
 461   1      #ifdef _DEBUG_
 462   1              usart_init();
 463   1              debug_uart_print_string("============================\r\n");
 464   1              debug_uart_print_string(">  Mini remote control box  \r\n");
 465   1              debug_uart_print_string(">  Version : 1.0            \r\n");
 466   1              debug_uart_print_string(">  Author  : GXY            \r\n");
 467   1              debug_uart_print_string("============================\r\n");    
 468   1      #endif
 469   1              box_status_init();
 470   1              timer0_init(); 
 471   1              limit_switch_init();
 472   1              IR_init();
 473   1              filter_init();
 474   1              system_clk_init();
 475   1              watchDog_init();
 476   1              //开启总中断                    
 477   1              EA = 1;         
 478   1      }
 479          
 480          void main(void)
 481          {
 482   1              board_init();
 483   1      
 484   1              while(1)
 485   1              {
 486   2                      //电机为活动状态
C51 COMPILER V9.00   MAIN                                                                  08/31/2016 20:59:53 PAGE 9   

 487   2                      if(BOX_IS_ACTIVE())
 488   2                      {
 489   3                              //平均值滤波器
 490   3                              if(sys_clk_100HZ_flag)
 491   3                              {                               
 492   4                                      AD_this_data = Motor_get_current(pMyMotor);     
 493   4                                      //去掉最旧的历史数据
 494   4                                      AD_data_sum -= AD_hist_data[AD_sample_pos];
 495   4                                      //添加最新的历史数据
 496   4                                      AD_hist_data[AD_sample_pos] =  AD_this_data;
 497   4                                      AD_data_sum += AD_this_data;
 498   4                                      //计算平均值            
 499   4                                      AD_filter_out = AD_data_sum >> 3;
 500   4                                      //改变数据指针（指向下一个最旧数据）
 501   4                                      AD_sample_pos++;
 502   4                                      if(AD_sample_pos >= sizeof(AD_hist_data))
 503   4                                      {
 504   5                                              AD_sample_pos = 0;              
 505   5                                      }
 506   4                                      //读取到电机的电流值，如果过大就自动停止
 507   4                                      if(AD_filter_out >= 12)
 508   4                                      {
 509   5                                              if(Box_status == STAT_BOX_CLOSING)
 510   5                                              {
 511   6                                                      box_close_finish();
 512   6                                              }
 513   5                                              else if(Box_status == STAT_BOX_OPENING)
 514   5                                              {
 515   6                                                      box_open_finish();      
 516   6                                              }
 517   5                                              else
 518   5                                              {
 519   6                                                      Motor_set_status(pMyMotor,MOTOR_STOP);
 520   6                                                      debug_uart_print_string("Undefined status!\r\n");
 521   6                                              }                       
 522   5                                              feed_dog();
 523   5                                              debug_uart_print_string("Motor is stoped to Motor current too much[");
 524   5                                              debug_uart_print_hex(pMyMotor->current);
 525   5                                              debug_uart_print_string("]\r\n");
 526   5                                      }
 527   4                                      sys_clk_100HZ_flag = 0;
 528   4                              }
 529   3                      }
 530   2                      //电机为非激活状态
 531   2                      else
 532   2                      {       
 533   3                              //没有待处理的数据,进入掉电模式
 534   3                              if(IR_RecvFlag == 0)
 535   3                              {
 536   4                                      debug_uart_print_string("Box is sleepping...\r\n");     
 537   4                                      MCU_sleep_mode();
 538   4                                      debug_uart_print_string("Box was waked up\r\n");  
 539   4                              }                               
 540   3                      }
 541   2                      //就在这也喂一次狗吧
 542   2                      feed_dog();     
 543   2                      //红外数据处理   
 544   2                      if(IR_RecvFlag)
 545   2                      {
 546   3                              //打印用户码和命令码
 547   3                              debug_uart_print_string("\r\nUser:[");
 548   3                              debug_uart_print_hex(this_recv_usr_code);
C51 COMPILER V9.00   MAIN                                                                  08/31/2016 20:59:53 PAGE 10  

 549   3                              debug_uart_print_string("]  Cmd:[");
 550   3                              debug_uart_print_hex(this_recv_cmd_code);
 551   3                              debug_uart_print_string("]\r\n"); 
 552   3                              //红外信息有效
 553   3                              if(IR_info.enable != 0xff)
 554   3                              {
 555   4                                      //用户码正确
 556   4                                      if(this_recv_usr_code == IR_info.user_code)
 557   4                                      {
 558   5                                              //打开和关闭命令码相同
 559   5                                              if(IR_info.open_code==IR_info.close_code)
 560   5                                              {
 561   6                                                      if(this_recv_cmd_code == IR_info.open_code)
 562   6                                                      {
 563   7                                                              if((Box_status & 0x03) == 0x01)
 564   7                                                              {
 565   8                                                                      goto close_Lable;
 566   8                                                              }
 567   7                                                              else if((Box_status & 0x03) == 0x02)
 568   7                                                              {
 569   8                                                                      goto open_Lable;
 570   8                                                              }
 571   7                                                      }
 572   6                                              }
 573   5                                              //打开盒子命令
 574   5                                              if(this_recv_cmd_code == IR_info.open_code)
 575   5                                              {
 576   6                                                      open_Lable:
 577   6                                                      //立即由正在关闭状态转变为打开延时1S，防止电流过大
 578   6                                                      if(Box_status == STAT_BOX_CLOSING)
 579   6                                                      {
 580   7                                                              box_stop_in_activity();
 581   7                                                              delayS(1);
 582   7                                                      }
 583   6                                                      filter_init();
 584   6                                                      box_open_begin();
 585   6                                                      set_times = 0;
 586   6                                              }
 587   5                                              //关闭盒子命令
 588   5                                              else if(this_recv_cmd_code ==IR_info.close_code)
 589   5                                              {
 590   6                                                      close_Lable:
 591   6                                                      //立即由正在打开状态转变为关闭延时1S，防止电流过大
 592   6                                                      if(Box_status == STAT_BOX_OPENING)
 593   6                                                      {
 594   7                                                              box_stop_in_activity();
 595   7                                                              delayS(1);                              
 596   7                                                      }
 597   6                                                      filter_init();
 598   6                                                      box_close_begin();
 599   6                                                      set_times = 0;
 600   6                                              }
 601   5                                              //设置红外遥控信息（出厂设置）
 602   5                                              else if(this_recv_cmd_code == IR_info.set_code)
 603   5                                              {       
 604   6                                                      box_stop_in_activity();
 605   6                                                      /*set_times++;
 606   6                                                      //连续按下关机键5次，恢复出厂设置
 607   6                                                      if(set_times>=5)
 608   6                                                      {
 609   6                                                              set_times = 0;                                                          
 610   6                                                              IR_recovery_factory_mode(&IR_info);
C51 COMPILER V9.00   MAIN                                                                  08/31/2016 20:59:53 PAGE 11  

 611   6                                                              debug_uart_print_string("Please press set code:\r\n");
 612   6                                                      }        */
 613   6                                              }
 614   5                                      #ifdef _DEBUG_
 615   5                                              //获取当前电流值命令（调试用）
 616   5                                              else if(this_recv_cmd_code == 22)
 617   5                                              {
 618   6                                                      debug_uart_print_string("current: [");
 619   6                                                      debug_uart_print_hex(Motor_get_current(pMyMotor));
 620   6                                                      debug_uart_print_string("]\r\n");
 621   6                                              }       
 622   5                                      #endif
 623   5                                              /*else
 624   5                                              {       
 625   5                                                      Motor_set_status(pMyMotor,MOTOR_STOP);
 626   5                                              }  */
 627   5                                      }
 628   4                              }
 629   3                              //红外遥控信息为空
 630   3                              else
 631   3                              {
 632   4                                      switch(set_index)
 633   4                                      {
 634   5                                              //第一次设置关机键
 635   5                                              case 0:
 636   5                                                      IR_info.set_code = this_recv_cmd_code;
 637   5                                                      IR_info.user_code = this_recv_usr_code;
 638   5                                                      debug_uart_print_string("Please press open code:\r\n");
 639   5                                                      break;
 640   5                                              //第二次设置打开盒子按键
 641   5                                              case 1:
 642   5                                                      IR_info.open_code = this_recv_cmd_code;
 643   5                                                      debug_uart_print_string("Please press close code:\r\n");
 644   5                                                      break;
 645   5                                              //第三次设置关闭盒子按键
 646   5                                              case 2:
 647   5                                                      IR_info.close_code = this_recv_cmd_code;
 648   5                                                      break;
 649   5                                      }
 650   4                                      //红外信息全部接收到后再一次性写入到EEPROM中保存                                
 651   4                                      set_index ++;
 652   4                                      if(set_index>=3)
 653   4                                      {
 654   5                                              set_index = 0;
 655   5                                              IR_remote_info_set(&IR_info);
 656   5                                              debug_uart_print_string("IR info set ok\r\n");
 657   5                                      }               
 658   4                              }                
 659   3                              IR_RecvFlag = 0;
 660   3                              IE0 = 0;
 661   3                              EX0 = 1;
 662   3                      }
 663   2                      feed_dog();
 664   2              }
 665   1      }
 666          
 667          u16 IR_wait_status(bit logicVal,u8 opt, u16 stdTime,u16 allowError)
 668          {
 669   1              u16 time;
 670   1      
 671   1              timer0_clear();
 672   1              time = 0;
C51 COMPILER V9.00   MAIN                                                                  08/31/2016 20:59:53 PAGE 12  

 673   1              timer0_start();
 674   1              while(time <= stdTime+allowError)
 675   1              {
 676   2                      time = timer0_read();
 677   2                      if(IR_Pin == logicVal && opt == SIG_BEGIN )
 678   2                      {
 679   3                              break;          
 680   3                      }
 681   2                      else if(IR_Pin != logicVal && opt == SIG_STOP)
 682   2                      {
 683   3                              break;
 684   3                      }                               
 685   2              }
 686   1              timer0_stop();
 687   1              if(time > stdTime + allowError || time < stdTime - allowError)
 688   1              {
 689   2                      return -1;
 690   2              }
 691   1              return time;
 692   1      }
 693          //红外接收中断服务程序
 694          void IR_rceived_int() interrupt 0
 695          {
 696   1              u16 result;
 697   1              u8 num,bit_n;
 698   1      
 699   1              if(IR_RecvFlag != 0)
 700   1              {
 701   2                      return;
 702   2              }
 703   1              //暂时关闭中断，防止数据接收出错
 704   1              EX0 = 0;
 705   1      
 706   1              //先喂一次狗狗
 707   1              feed_dog();
 708   1      
 709   1              //接受红外的引导码
 710   1              result = IR_wait_status(0, SIG_STOP, IR_HEADER_TIME_Y, 1000);
 711   1              ASSERT(result,"IR head error 1\r\n");   
 712   1              result = IR_wait_status(1, SIG_STOP, IR_HEADER_TIME_N, IR_HEADER_TIME_N);
 713   1              ASSERT(result,"IR head error 2\r\n");
 714   1      
 715   1              for(num=0; num<sizeof(IR_RecvBuf); num++)
 716   1              {
 717   2                      for(bit_n=0; bit_n<8; bit_n++)
 718   2                      {
 719   3                              result = IR_wait_status(0, SIG_STOP, IR_DATA_TIME_Y, 200);
 720   3                              ASSERT(result,"IR data error 1\r\n");
 721   3                              result = IR_wait_status(1, SIG_STOP, 1170, 810);
 722   3                              //result = IR_wait_status(0, SIG_BEGIN, (IR_LOGIC_1_CYCLE + IR_LOGIC_1_CYCLE)>>1, (IR_LOGIC_1_CYCLE>>1)
             -+200);
 723   3                              ASSERT(result,"IR data error 2\r\n");
 724   3                              IR_RecvBuf[num] >>= 1;
 725   3                              if(result > IR_DATA_TIME_Y-200 && result < IR_DATA_TIME_Y+200)
 726   3                              {
 727   4                                      
 728   4                              }
 729   3                              else
 730   3                              {
 731   4                                      IR_RecvBuf[num] |= 0x80;
 732   4                              }
 733   3                      }
C51 COMPILER V9.00   MAIN                                                                  08/31/2016 20:59:53 PAGE 13  

 734   2              }
 735   1              //喂狗
 736   1              feed_dog();
 737   1      
 738   1              //确认IR信号线被释放
 739   1              while(IR_wait_status(1, SIG_STOP, 50000, 50000)!=-1);
 740   1      
 741   1              //校验数据
 742   1              if(IR_RecvBuf[0] == ~IR_RecvBuf[1] && IR_RecvBuf[2] == ~IR_RecvBuf[3])
 743   1              {
 744   2                      //接收成功，关闭中断等待处理完成
 745   2                      IR_RecvFlag = 1;
 746   2                      EX0 = 0;        
 747   2              }               
 748   1              else
 749   1              {
 750   2                      //接收出错，恢复中断准备下次接收
 751   2                      debug_uart_print_string_int("code check error!\r\n");
 752   2                      EX0 = 1;                
 753   2              }       
 754   1              IE0 = 0;        
 755   1      }
 756          //小盒闭合的限位开关0中断服务程序(主要)
 757          void limit_switch0() interrupt 2
 758          {
 759   1              if(Box_status == STAT_BOX_CLOSING)
 760   1              {
 761   2                      box_close_finish();
 762   2              }
 763   1              IR_recovery_factory_mode(&IR_info);
 764   1              //debug_uart_print_string_int("limit switch [0] is trigered!\r\n");
 765   1              IE1 = 0;
 766   1      }
 767          //小盒打开的限位开关1中断服务程序
 768          void limit_switch1() interrupt 10
 769          {
 770   1              if(Box_status == STAT_BOX_OPENING)
 771   1              {
 772   2                      box_open_finish();
 773   2              }
 774   1              debug_uart_print_string_int("limit switch [1] is trigered!\r\n");
 775   1      }
 776          //系统时钟中断服务
 777          void PCA_isr() interrupt 7 using 1
 778          {
 779   1          CCF0 = 0;                       //清中断标志
 780   1          CCAP0L = value;
 781   1          CCAP0H = value >> 8;            //更新比较值
 782   1          value += T100Hz;
 783   1              sys_clk_100HZ_flag = 1;
 784   1      }
 785          
 786          
 787          
 788          
 789          
 790          
 791          /*void box_open_error(void)
 792          {
 793                  Motor_set_status(pMyMotor,MOTOR_STOP);
 794                  Box_status = STAT_BOX_OPEN_ERROR;       
 795                  debug_uart_print_string_int("box_open_error\r\n");
C51 COMPILER V9.00   MAIN                                                                  08/31/2016 20:59:53 PAGE 14  

 796          }
 797          void box_close_error(void)
 798          {
 799                  Motor_set_status(pMyMotor,MOTOR_STOP);
 800                  Box_status = STAT_BOX_CLOSE_ERROR;
 801                  debug_uart_print_string_int("box_close_error\r\n");
 802          }                  */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2420    ----
   CONSTANT SIZE    =    716    ----
   XDATA SIZE       =     19    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     40      28
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
