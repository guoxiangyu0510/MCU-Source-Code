C51 COMPILER V9.00   MAIN                                                                  09/20/2016 20:51:59 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\obj\main.obj
COMPILER INVOKED BY: D:\Program Files\KeilC51V9.00\C51\BIN\C51.EXE ..\user\main.c BROWSE INCDIR(..\include) DEBUG OBJECT
                    -EXTEND PRINT(..\list\main.lst) OBJECT(..\obj\main.obj)

line level    source

   1          /*
   2                  待完成功能
   3                  1.产品出厂初始设定：产品关机键连续按5次启动出厂设置
   4                                                          即按顺序学习小盒的关闭和打开遥控命令
   5                                                          （此功能有可能会无意中混乱按键，为防止此情况发生，
   6                                                            加入recover Pin有硬件操作完成）
   7                  2.出现阻转故障后的处理
   8                  3.添加看门狗
   9                  4.增加AD采样滤波器
  10                  5.考虑添加复位按键
  11                  6.软启动功能
  12          
  13                  功能描述
  14                  1.
  15                  2.
  16                  3.
  17                  4.
  18          */
  19          
  20          #include <STC15.h>
  21          #include <string.h>
  22          #include <intrins.h>
  23          #include "timer0.h"
  24          #include "typeDef.h"
  25          #include "motor.h"
  26          #include "math.h"
  27          #include "eeprom.h"
  28          
  29          #define FOSC    12000000L
  30          #define T100Hz  (FOSC / 12 / 100)
  31          #define CCP_S0 0x10                 //P_SW1.4
  32          #define CCP_S1 0x20                 //P_SW1.5
  33          
  34          #define IR_HEADER_TIME_Y 9000           //前导码有38K调制波时间 9ms
  35          #define IR_HEADER_TIME_N 4500           //前导码无38K调制波时间 4.5ms
  36          #define IR_DATA_TIME_Y   560            //数据码有38K调制波固定时间     0.56ms
  37          #define IR_LOGIC_1_CYCLE 2250           //逻辑1时数据码周期         2.25ms
  38          #define IR_LOGIC_0_CYCLE 1120           //逻辑0时数据码周期             1.12ms
  39          #define this_recv_usr_code IR_RecvBuf[0]
  40          #define this_recv_cmd_code IR_RecvBuf[2]
  41          #define IR_IAP_INFO_ADDR 0x0400
  42          
  43          #define SIG_STOP 0
  44          #define SIG_BEGIN 1
  45          
  46          //*********************************
  47          //About Box status
  48          // x     x       x        x      x       x              xx
  49          //活动 完成     错误  0  0   0   1:打开 2:关闭
  50          #define STAT_BOX_OPENING        0x81
  51          #define STAT_BOX_OPENED         0x41
  52          #define STAT_BOX_CLOSING        0x82
  53          #define STAT_BOX_CLOSED         0x42
  54          #define STAT_BOX_OPEN_ERROR     0x21
C51 COMPILER V9.00   MAIN                                                                  09/20/2016 20:51:59 PAGE 2   

  55          #define STAT_BOX_CLOSE_ERROR 0x22
  56          #define STAT_BOX_STOP_IN_OP     0x01
  57          #define STAT_BOX_STOP_IN_CL     0x02
  58          
  59          #define BOX_IS_ACTIVE() ((Box_status&0x80) != 0)
  60          #define BOX_IS_FINISH() ((Box_status&0x40) != 0)
  61          
  62          #define ASSERT(RESULT,FLAG)                                                                                     \
  63                                  if(RESULT == -1 )                                                                                       \
  64                                  {                                                                                                                       \
  65                                          debug_uart_print_string_int(FLAG);                                              \
  66                                          while(IR_wait_status(1, SIG_STOP, 6000, 6000)!=-1);             \
  67                                          IE0=0;EX0 = 1;                                                                                  \
  68                                          return;                                                                                                 \
  69                                  }
  70          
  71          #define _DEBUG_
  72          
  73          sbit IR_Pin = P3^2;
  74          
  75          u8 IR_RecvBuf[4],IR_RecvFlag,set_times,set_index;
  76          
  77          u8 IR_usr_code,IR_cmd_code;
  78          
  79          u8 Box_status;
  80          
  81          #define AD_HIST_SIZE 8
  82          u8 xdata AD_hist_data[AD_HIST_SIZE];
  83          u8 xdata AD_sample_pos;
  84          u8 xdata AD_data_max,AD_data_min;
  85          u16 xdata AD_data_sum;
  86          u8 xdata AD_this_data;
  87          u8 xdata AD_filter_out;
  88          
  89          struct motor myMotor,*pMyMotor;
  90          
  91          struct IR_info_t
  92          {       
  93                  u8 user_code;   //用户码                
  94                  u8 set_code;    //设置键码      
  95                  u8 open_code;   //打开键码
  96                  u8 close_code;  //关闭键码
  97                  u8 enable;              //IR信息有效标记
  98          }IR_info;
  99          
 100          u8 xdata cnt, sys_clk_100HZ_flag;
 101          u16 xdata value;
 102          
 103          
 104          
 105          #if defined (_DEBUG_)
 106          #define debug_uart_print_string(str) uart_print_string(str)
 107          #define debug_uart_print_value(val)  uart_print_value(val)
 108          #define debug_uart_print_hex(val)        uart_print_hex(val)
 109          #define debug_uart_print_string_int(str) uart_print_string_int(str)
 110          void usart_init(void)
 111          {
 112   1              SCON = 0x50;            //8位数据,可变波特率
 113   1              AUXR |= 0x01;           //串口1选择定时器2为波特率发生器
 114   1              AUXR |= 0x04;           //定时器2时钟为Fosc,即1T
 115   1              T2L = 0xC7;                     //设定定时初值
 116   1              T2H = 0xFE;                     //设定定时初值
C51 COMPILER V9.00   MAIN                                                                  09/20/2016 20:51:59 PAGE 3   

 117   1              AUXR |= 0x10;           //启动定时器2   
 118   1      }
 119          char putchar (char c)  
 120          {
 121   1              SBUF = c;
 122   1              while (!TI);
 123   1              TI = 0;
 124   1              return c;
 125   1      }
 126          void uart_print_string_int(char *str)
 127          {
 128   1              while(*str !='\0')
 129   1              {
 130   2                      putchar(*str);
 131   2                      str++;
 132   2              }
 133   1      }
 134          void uart_print_string(char *str)
 135          {
 136   1              char ch;
 137   1      
 138   1              ch = *str;
 139   1              while(ch != '\0')
 140   1              {               
 141   2                      if(ch == '\\')
 142   2                      {
 143   3                              switch(*(str+1))
 144   3                              {
 145   4                                      case 'n': ch='\n'; str ++; break;
 146   4                                      case 'r': ch='\r'; str ++; break;
 147   4                                      case 't': ch='\t'; str ++; break;
 148   4                              }       
 149   3                      }
 150   2                      putchar(ch);
 151   2                      str ++;
 152   2                      ch = *str;
 153   2              }
 154   1      }
 155          void uart_print_value(int value)
 156          {
 157   1              int base;
 158   1              
 159   1              base = 10000;
 160   1              if(value < 0)
 161   1              {
 162   2                      value = abs(value);
 163   2                      putchar('-');
 164   2              }
 165   1              while(base != 0)
 166   1              {               
 167   2                      putchar('0'+value/base);
 168   2                      value %= base;
 169   2                      base/=10;
 170   2              }
 171   1      }
 172          char hexTab[]="01234567890ABCDEF";
 173          void uart_print_hex(u8 value)
 174          {
 175   1              putchar(hexTab[value>>4]);
 176   1              putchar(hexTab[value&0x0f]);            
 177   1      }
 178          #else
C51 COMPILER V9.00   MAIN                                                                  09/20/2016 20:51:59 PAGE 4   

                      #define debug_uart_print_string(str) 
                      #define debug_uart_print_value(val) 
                      #define debug_uart_print_string_int(str)        
              #endif
 183          
 184          /*=============================*/
 185          /*       看门狗初始化（打开状态）
 186          /*=============================*/
 187          #define feed_dog() (WDT_CONTR|=0x10)
 188          #define watchDog_disable() (WDT_CONTR&=~0x20)
 189          #define watchDog_enable()  (WDT_CONTR|=0x20)
 190          void watchDog_init(void)
 191          {
 192   1              //看门狗定时器溢出时间计算公式: (12 * 32768 * PS) / FOSC (秒)
 193   1              //12M : 1.0485s
 194   1              WDT_CONTR = 0x04;                        
 195   1              watchDog_enable();      
 196   1      }
 197          /*=============================*/
 198          /*                软件延时
 199          /*=============================*/
 200          void delayMs(u8 time)
 201          {
 202   1              u16 timeUs;
 203   1      
 204   1              timeUs = (time>=65)? 65000:(time*1000);
 205   1              timer0_clear();
 206   1              timer0_start();
 207   1              while(timer0_read() < timeUs);
 208   1              timer0_stop();
 209   1      }
 210          void delayS(unsigned char time)
 211          {
 212   1              u16 temp;
 213   1      
 214   1              feed_dog();      //喂狗
 215   1              temp = time*20;
 216   1              for(;temp>0;temp--)
 217   1              {
 218   2                      delayMs(50);
 219   2                      feed_dog();      //喂狗
 220   2              }
 221   1      }
 222          
 223          /*=============================*/
 224          /*                系统时钟初始化
 225          /*=============================*/
 226          void system_clk_init(void)
 227          {
 228   1              ACC = P_SW1;
 229   1          ACC &= ~(CCP_S0 | CCP_S1);      //CCP_S0=0 CCP_S1=0
 230   1          P_SW1 = ACC;                    //(P1.2/ECI, P1.1/CCP0, P1.0/CCP1, P3.7/CCP2)
 231   1          
 232   1      //  ACC = P_SW1;
 233   1      //  ACC &= ~(CCP_S0 | CCP_S1);      //CCP_S0=1 CCP_S1=0
 234   1      //  ACC |= CCP_S0;                  //(P3.4/ECI_2, P3.5/CCP0_2, P3.6/CCP1_2, P3.7/CCP2_2)
 235   1      //  P_SW1 = ACC;  
 236   1      //  
 237   1      //  ACC = P_SW1;
 238   1      //  ACC &= ~(CCP_S0 | CCP_S1);      //CCP_S0=0 CCP_S1=1
 239   1      //  ACC |= CCP_S1;                  //(P2.4/ECI_3, P2.5/CCP0_3, P2.6/CCP1_3, P2.7/CCP2_3)
 240   1      //  P_SW1 = ACC;  
C51 COMPILER V9.00   MAIN                                                                  09/20/2016 20:51:59 PAGE 5   

 241   1      
 242   1          CCON = 0;                       //初始化PCA控制寄存器
 243   1                                          //PCA定时器停止
 244   1                                          //清除CF标志
 245   1                                          //清除模块中断标志
 246   1          CL = 0;                         //复位PCA寄存器
 247   1          CH = 0;
 248   1          CMOD = 0x00;                    //设置PCA时钟源
 249   1                                          //禁止PCA定时器溢出中断
 250   1          value = T100Hz;
 251   1          CCAP0L = value;
 252   1          CCAP0H = value >> 8;            //初始化PCA模块0
 253   1          value += T100Hz;
 254   1          CCAPM0 = 0x49;                  //PCA模块0为16位定时器模式
 255   1      
 256   1          CR = 1;                         //PCA定时器开始工作
 257   1              sys_clk_100HZ_flag = 0;
 258   1          cnt = 0;
 259   1      }
 260          
 261          /*=============================*/
 262          /*        红外信息恢复出厂状态
 263          /*=============================*/
 264          s8 IR_recovery_factory_mode(struct IR_info_t *info)
 265          {
 266   1              if(info->enable != 0xff)
 267   1              {
 268   2                      IapEraseSector(IR_IAP_INFO_ADDR);
 269   2                      info->user_code = 0xff;
 270   2                      info->set_code = 0xff;
 271   2                      info->open_code = 0xff;
 272   2                      info->close_code = 0xff;
 273   2                      info->enable = 0xff;
 274   2              }
 275   1              debug_uart_print_string_int("IR is recovery factory mode\r\n");
 276   1      
 277   1              return 0;
 278   1      }
 279          
 280          /*=============================*/
 281          /*      设置红外信息（保存到eeprom）
 282          /*=============================*/
 283          s8 IR_remote_info_set(struct IR_info_t *info)
 284          {
 285   1              IapEraseSector(IR_IAP_INFO_ADDR);
 286   1              IapProgramByte(IR_IAP_INFO_ADDR,0x55);
 287   1              IapProgramByte(IR_IAP_INFO_ADDR+1,info->user_code);
 288   1              IapProgramByte(IR_IAP_INFO_ADDR+2,info->set_code);
 289   1              IapProgramByte(IR_IAP_INFO_ADDR+3,info->open_code);
 290   1              IapProgramByte(IR_IAP_INFO_ADDR+4,info->close_code);
 291   1              info->enable = 0x00;
 292   1              debug_uart_print_string_int("IR remote info set ok\r\n");
 293   1      
 294   1              return 0;               
 295   1      }
 296          
 297          /*=============================*/
 298          /*        从eeprom中读取IR信息
 299          /*=============================*/
 300          s8 IR_info_read_from_eeprom(struct IR_info_t *info)
 301          {
 302   1              if(IapReadByte(IR_IAP_INFO_ADDR) == 0x55)
C51 COMPILER V9.00   MAIN                                                                  09/20/2016 20:51:59 PAGE 6   

 303   1              {
 304   2                      info->user_code = IapReadByte(IR_IAP_INFO_ADDR+1);
 305   2                      info->set_code  = IapReadByte(IR_IAP_INFO_ADDR+2);
 306   2                      info->open_code  = IapReadByte(IR_IAP_INFO_ADDR+3);
 307   2                      info->close_code  = IapReadByte(IR_IAP_INFO_ADDR+4);
 308   2                      info->enable = 0x00;
 309   2                      debug_uart_print_string_int("IR remote info read ok\r\n");
 310   2      
 311   2                      return 0;
 312   2              } 
 313   1              info->enable = 0xFF;
 314   1              debug_uart_print_string_int("IR remote info is null\r\n");
 315   1      
 316   1              debug_uart_print_string_int("Please press shutdown code:\r\n");
 317   1              return -1;
 318   1      }
 319          
 320          /*=============================*/
 321          /*                红外控制初始化
 322          /*=============================*/
 323          void IR_init(void)
 324          {
 325   1              P32 = 1;
 326   1              //下降沿触发
 327   1              IT0 = 1;
 328   1              memset(IR_RecvBuf, 0, sizeof(IR_RecvBuf));
 329   1              IR_RecvFlag = 0;
 330   1              set_times = 0;
 331   1              set_index = 0;
 332   1              IR_info_read_from_eeprom(&IR_info);
 333   1              EX0 = 1;        
 334   1      }
 335          
 336          /*=============================*/
 337          /*                限位开关初始化
 338          /*=============================*/
 339          void limit_switch_init(void)
 340          {
 341   1              P33 = P36 = 1;
 342   1              INT_CLKO |= 0x10;
 343   1              IT1 = 1;
 344   1              EX1 = 1;
 345   1      }
 346          
 347          /*=============================*/
 348          /*              平均值滤波器初始化
 349          /*=============================*/
 350          void filter_init(void)
 351          {
 352   1              memset(AD_hist_data,0,sizeof(AD_hist_data));
 353   1              AD_sample_pos = 0;
 354   1              AD_data_max = 0;
 355   1              AD_data_min = 0;
 356   1              AD_data_sum = 0;
 357   1              AD_this_data = 0;
 358   1              AD_filter_out = 0;
 359   1      }
 360          
 361          /*=============================*/
 362          /*        MCU进入掉电模式（睡眠）
 363          /*=============================*/
 364          void MCU_sleep_mode(void)
C51 COMPILER V9.00   MAIN                                                                  09/20/2016 20:51:59 PAGE 7   

 365          {       
 366   1              //进入掉电模式之前确保外部中断为开启状态
 367   1              IE0 = 0;
 368   1              EX0 = 1;
 369   1              EA = 1;
 370   1              //MCU进入掉电模式
 371   1              PCON = 0x02;            
 372   1              //掉电模式被唤醒后,首先执行此语句,然后再进入中断服务程序
 373   1              _nop_();                
 374   1          _nop_();
 375   1              _nop_();
 376   1              _nop_();
 377   1      }
 378          
 379          /*=============================*/
 380          /*                打开盒子
 381          /*=============================*/
 382          void box_open_begin(void)
 383          {
 384   1              if(Box_status != STAT_BOX_OPENED && Box_status != STAT_BOX_OPENING)// && Box_status !=STAT_BOX_OPEN_ERROR
             -)
 385   1              {
 386   2                      Motor_set_status(pMyMotor,MOTOR_FORWORD);
 387   2                      Box_status = STAT_BOX_OPENING;          
 388   2                      debug_uart_print_string_int("Box is openning ...\r\n");                 
 389   2              }
 390   1              else
 391   1              {
 392   2                      debug_uart_print_string_int("Box_open_finish\r\n");
 393   2              }               
 394   1      }
 395          void box_open_finish(void)
 396          {
 397   1              if(Box_status != STAT_BOX_OPENED)
 398   1              {
 399   2                      Motor_set_status(pMyMotor,MOTOR_STOP);
 400   2                      Box_status = STAT_BOX_OPENED;
 401   2              }       
 402   1              debug_uart_print_string_int("Box_open_finish\r\n");             
 403   1      }
 404          
 405          void box_close_begin(void)
 406          {
 407   1              if(Box_status != STAT_BOX_CLOSED && Box_status != STAT_BOX_CLOSING)// && Box_status !=STAT_BOX_CLOSE_ERRO
             -R)
 408   1              {
 409   2                      Motor_set_status(pMyMotor,MOTOR_REVERSAL);      
 410   2                      Box_status = STAT_BOX_CLOSING;
 411   2                      debug_uart_print_string_int("Box is closing ...\r\n");          
 412   2              } 
 413   1              else
 414   1              {
 415   2                      debug_uart_print_string_int("Box close finish\r\n");    
 416   2              }       
 417   1      }
 418          void box_close_finish(void)
 419          {
 420   1              if(Box_status != STAT_BOX_CLOSED)
 421   1              {
 422   2                      Motor_set_status(pMyMotor,MOTOR_STOP); 
 423   2                      Box_status = STAT_BOX_CLOSED;
 424   2              }       
C51 COMPILER V9.00   MAIN                                                                  09/20/2016 20:51:59 PAGE 8   

 425   1              debug_uart_print_string_int("Box close finish\r\n");
 426   1      }
 427          
 428          void box_stop_in_activity()
 429          {
 430   1              if(BOX_IS_ACTIVE())
 431   1              {
 432   2                      Motor_set_status(pMyMotor,MOTOR_STOP);
 433   2                      if( !BOX_IS_FINISH() )
 434   2                      {
 435   3                              if(Box_status == STAT_BOX_OPENING)
 436   3                              {
 437   4                                      Box_status = STAT_BOX_STOP_IN_OP;
 438   4                              }
 439   3                              else
 440   3                              {
 441   4                                      Box_status = STAT_BOX_STOP_IN_CL;       
 442   4                              }       
 443   3                      }
 444   2                      debug_uart_print_string_int("Box stop in activity\r\n");
 445   2              }       
 446   1              else
 447   1              {
 448   2                      debug_uart_print_string_int("Box always is stoped!\r\n");
 449   2              }
 450   1      }
 451          /*=============================*/
 452          /*                盒子初始状态设置
 453          /*=============================*/
 454          void box_status_init(void)
 455          {
 456   1              pMyMotor = &myMotor;
 457   1              Motor_init(pMyMotor);
 458   1              Box_status = STAT_BOX_STOP_IN_OP;
 459   1              box_stop_in_activity(); 
 460   1      }
 461          
 462          /*=============================*/
 463          /*                板级初始化
 464          /*=============================*/
 465          void board_init(void)
 466          {
 467   1      #ifdef _DEBUG_
 468   1              usart_init();
 469   1              debug_uart_print_string("============================\r\n");
 470   1              debug_uart_print_string(">  Mini remote control box  \r\n");
 471   1              debug_uart_print_string(">  Version : 1.0            \r\n");
 472   1              debug_uart_print_string(">  Author  : GXY            \r\n");
 473   1              debug_uart_print_string("============================\r\n");    
 474   1      #endif
 475   1              box_status_init();
 476   1              timer0_init(); 
 477   1              limit_switch_init();
 478   1              IR_init();
 479   1              filter_init();
 480   1              system_clk_init();
 481   1              watchDog_init();
 482   1              //开启总中断                    
 483   1              EA = 1;         
 484   1      }
 485          
 486          void main(void)
C51 COMPILER V9.00   MAIN                                                                  09/20/2016 20:51:59 PAGE 9   

 487          {
 488   1              board_init();
 489   1      
 490   1              while(1)
 491   1              {
 492   2                      //电机为活动状态
 493   2                      if(BOX_IS_ACTIVE())
 494   2                      {
 495   3                              //平均值滤波器
 496   3                              if(sys_clk_100HZ_flag)
 497   3                              {                               
 498   4                                      AD_this_data = Motor_get_current(pMyMotor);     
 499   4                                      //去掉最旧的历史数据
 500   4                                      AD_data_sum -= AD_hist_data[AD_sample_pos];
 501   4                                      //添加最新的历史数据
 502   4                                      AD_hist_data[AD_sample_pos] =  AD_this_data;
 503   4                                      AD_data_sum += AD_this_data;
 504   4                                      //计算平均值            
 505   4                                      AD_filter_out = AD_data_sum >> 3;
 506   4                                      //改变数据指针（指向下一个最旧数据）
 507   4                                      AD_sample_pos++;
 508   4                                      if(AD_sample_pos >= sizeof(AD_hist_data))
 509   4                                      {
 510   5                                              AD_sample_pos = 0;              
 511   5                                      }
 512   4                                      //读取到电机的电流值，如果过大就自动停止
 513   4                                      if(AD_filter_out >= 12)
 514   4                                      {
 515   5                                              if(Box_status == STAT_BOX_CLOSING)
 516   5                                              {
 517   6                                                      box_close_finish();
 518   6                                              }
 519   5                                              else if(Box_status == STAT_BOX_OPENING)
 520   5                                              {
 521   6                                                      box_open_finish();      
 522   6                                              }
 523   5                                              else
 524   5                                              {
 525   6                                                      Motor_set_status(pMyMotor,MOTOR_STOP);
 526   6                                                      debug_uart_print_string("Undefined status!\r\n");
 527   6                                              }                       
 528   5                                              feed_dog();
 529   5                                              debug_uart_print_string("Motor is stoped to Motor current too much[");
 530   5                                              debug_uart_print_hex(pMyMotor->current);
 531   5                                              debug_uart_print_string("]\r\n");
 532   5                                      }
 533   4                                      sys_clk_100HZ_flag = 0;
 534   4                              }
 535   3                      }
 536   2                      //电机为非激活状态
 537   2                      else
 538   2                      {       
 539   3                              //没有待处理的数据,进入掉电模式
 540   3                              if(IR_RecvFlag == 0)
 541   3                              {
 542   4                                      debug_uart_print_string("Box is sleepping...\r\n");     
 543   4                                      MCU_sleep_mode();
 544   4                                      debug_uart_print_string("Box was waked up\r\n");  
 545   4                              }                               
 546   3                      }
 547   2                      //就在这也喂一次狗吧
 548   2                      feed_dog();     
C51 COMPILER V9.00   MAIN                                                                  09/20/2016 20:51:59 PAGE 10  

 549   2                      //红外数据处理   
 550   2                      if(IR_RecvFlag)
 551   2                      {
 552   3                              //打印用户码和命令码
 553   3                              debug_uart_print_string("\r\nUser:[");
 554   3                              debug_uart_print_hex(this_recv_usr_code);
 555   3                              debug_uart_print_string("]  Cmd:[");
 556   3                              debug_uart_print_hex(this_recv_cmd_code);
 557   3                              debug_uart_print_string("]\r\n"); 
 558   3                              //红外信息有效
 559   3                              if(IR_info.enable != 0xff)
 560   3                              {
 561   4                                      //用户码正确
 562   4                                      if(this_recv_usr_code == IR_info.user_code)
 563   4                                      {
 564   5                                              //打开和关闭命令码相同
 565   5                                              if(IR_info.open_code==IR_info.close_code)
 566   5                                              {
 567   6                                                      if(this_recv_cmd_code == IR_info.open_code)
 568   6                                                      {
 569   7                                                              if((Box_status & 0x03) == 0x01)
 570   7                                                              {
 571   8                                                                      goto close_Lable;
 572   8                                                              }
 573   7                                                              else if((Box_status & 0x03) == 0x02)
 574   7                                                              {
 575   8                                                                      goto open_Lable;
 576   8                                                              }
 577   7                                                      }
 578   6                                              }
 579   5                                              //打开盒子命令
 580   5                                              if(this_recv_cmd_code == IR_info.open_code)
 581   5                                              {
 582   6                                                      open_Lable:
 583   6                                                      //立即由正在关闭状态转变为打开延时1S，防止电流过大
 584   6                                                      if(Box_status == STAT_BOX_CLOSING)
 585   6                                                      {
 586   7                                                              box_stop_in_activity();
 587   7                                                              delayS(1);
 588   7                                                      }
 589   6                                                      filter_init();
 590   6                                                      box_open_begin();
 591   6                                                      set_times = 0;
 592   6                                              }
 593   5                                              //关闭盒子命令
 594   5                                              else if(this_recv_cmd_code ==IR_info.close_code)
 595   5                                              {
 596   6                                                      close_Lable:
 597   6                                                      //立即由正在打开状态转变为关闭延时1S，防止电流过大
 598   6                                                      if(Box_status == STAT_BOX_OPENING)
 599   6                                                      {
 600   7                                                              box_stop_in_activity();
 601   7                                                              delayS(1);                              
 602   7                                                      }
 603   6                                                      filter_init();
 604   6                                                      box_close_begin();
 605   6                                                      set_times = 0;
 606   6                                              }
 607   5                                              //设置红外遥控信息（出厂设置）
 608   5                                              else if(this_recv_cmd_code == IR_info.set_code)
 609   5                                              {       
 610   6                                                      box_stop_in_activity();
C51 COMPILER V9.00   MAIN                                                                  09/20/2016 20:51:59 PAGE 11  

 611   6                                                      /*set_times++;
 612   6                                                      //连续按下关机键5次，恢复出厂设置
 613   6                                                      if(set_times>=5)
 614   6                                                      {
 615   6                                                              set_times = 0;                                                          
 616   6                                                              IR_recovery_factory_mode(&IR_info);
 617   6                                                              debug_uart_print_string("Please press set code:\r\n");
 618   6                                                      }        */
 619   6                                              }
 620   5                                      #ifdef _DEBUG_
 621   5                                              //获取当前电流值命令（调试用）
 622   5                                              else if(this_recv_cmd_code == 22)
 623   5                                              {
 624   6                                                      debug_uart_print_string("current: [");
 625   6                                                      debug_uart_print_hex(Motor_get_current(pMyMotor));
 626   6                                                      debug_uart_print_string("]\r\n");
 627   6                                              }       
 628   5                                      #endif
 629   5                                              /*else
 630   5                                              {       
 631   5                                                      Motor_set_status(pMyMotor,MOTOR_STOP);
 632   5                                              }  */
 633   5                                      }
 634   4                              }
 635   3                              //红外遥控信息为空
 636   3                              else
 637   3                              {
 638   4                                      switch(set_index)
 639   4                                      {
 640   5                                              //第一次设置关机键
 641   5                                              case 0:
 642   5                                                      IR_info.set_code = this_recv_cmd_code;
 643   5                                                      IR_info.user_code = this_recv_usr_code;
 644   5                                                      debug_uart_print_string("Please press open code:\r\n");
 645   5                                                      break;
 646   5                                              //第二次设置打开盒子按键
 647   5                                              case 1:
 648   5                                                      IR_info.open_code = this_recv_cmd_code;
 649   5                                                      debug_uart_print_string("Please press close code:\r\n");
 650   5                                                      break;
 651   5                                              //第三次设置关闭盒子按键
 652   5                                              case 2:
 653   5                                                      IR_info.close_code = this_recv_cmd_code;
 654   5                                                      break;
 655   5                                      }
 656   4                                      //红外信息全部接收到后再一次性写入到EEPROM中保存                                
 657   4                                      set_index ++;
 658   4                                      if(set_index>=3)
 659   4                                      {
 660   5                                              set_index = 0;
 661   5                                              IR_remote_info_set(&IR_info);
 662   5                                              debug_uart_print_string("IR info set ok\r\n");
 663   5                                      }               
 664   4                              }                
 665   3                              IR_RecvFlag = 0;
 666   3                              IE0 = 0;
 667   3                              EX0 = 1;
 668   3                      }
 669   2                      feed_dog();
 670   2              }
 671   1      }
 672          
C51 COMPILER V9.00   MAIN                                                                  09/20/2016 20:51:59 PAGE 12  

 673          u16 IR_wait_status(bit logicVal,u8 opt, u16 stdTime,u16 allowError)
 674          {
 675   1              u16 time;
 676   1      
 677   1              timer0_clear();
 678   1              time = 0;
 679   1              timer0_start();
 680   1              while(time <= stdTime+allowError)
 681   1              {
 682   2                      time = timer0_read();
 683   2                      if(IR_Pin == logicVal && opt == SIG_BEGIN )
 684   2                      {
 685   3                              break;          
 686   3                      }
 687   2                      else if(IR_Pin != logicVal && opt == SIG_STOP)
 688   2                      {
 689   3                              break;
 690   3                      }                               
 691   2              }
 692   1              timer0_stop();
 693   1              if(time > stdTime + allowError || time < stdTime - allowError)
 694   1              {
 695   2                      return -1;
 696   2              }
 697   1              return time;
 698   1      }
 699          //红外接收中断服务程序
 700          void IR_rceived_int() interrupt 0
 701          {
 702   1              u16 result;
 703   1              u8 num,bit_n;
 704   1      
 705   1              if(IR_RecvFlag != 0)
 706   1              {
 707   2                      return;
 708   2              }
 709   1              //暂时关闭中断，防止数据接收出错
 710   1              EX0 = 0;
 711   1      
 712   1              //先喂一次狗狗
 713   1              feed_dog();
 714   1      
 715   1              //接受红外的引导码
 716   1              result = IR_wait_status(0, SIG_STOP, IR_HEADER_TIME_Y, 1000);
 717   1              ASSERT(result,"IR head error 1\r\n");   
 718   1              result = IR_wait_status(1, SIG_STOP, IR_HEADER_TIME_N, IR_HEADER_TIME_N);
 719   1              ASSERT(result,"IR head error 2\r\n");
 720   1      
 721   1              for(num=0; num<sizeof(IR_RecvBuf); num++)
 722   1              {
 723   2                      for(bit_n=0; bit_n<8; bit_n++)
 724   2                      {
 725   3                              result = IR_wait_status(0, SIG_STOP, IR_DATA_TIME_Y, 200);
 726   3                              ASSERT(result,"IR data error 1\r\n");
 727   3                              result = IR_wait_status(1, SIG_STOP, 1170, 810);
 728   3                              //result = IR_wait_status(0, SIG_BEGIN, (IR_LOGIC_1_CYCLE + IR_LOGIC_1_CYCLE)>>1, (IR_LOGIC_1_CYCLE>>1)
             -+200);
 729   3                              ASSERT(result,"IR data error 2\r\n");
 730   3                              IR_RecvBuf[num] >>= 1;
 731   3                              if(result > IR_DATA_TIME_Y-200 && result < IR_DATA_TIME_Y+200)
 732   3                              {
 733   4                                      
C51 COMPILER V9.00   MAIN                                                                  09/20/2016 20:51:59 PAGE 13  

 734   4                              }
 735   3                              else
 736   3                              {
 737   4                                      IR_RecvBuf[num] |= 0x80;
 738   4                              }
 739   3                      }
 740   2              }
 741   1              //喂狗
 742   1              feed_dog();
 743   1      
 744   1              //确认IR信号线被释放
 745   1              while(IR_wait_status(1, SIG_STOP, 50000, 50000)!=-1);
 746   1      
 747   1              //校验数据
 748   1              if(IR_RecvBuf[0] == ~IR_RecvBuf[1] && IR_RecvBuf[2] == ~IR_RecvBuf[3])
 749   1              {
 750   2                      //接收成功，关闭中断等待处理完成
 751   2                      IR_RecvFlag = 1;
 752   2                      EX0 = 0;        
 753   2              }               
 754   1              else
 755   1              {
 756   2                      //接收出错，恢复中断准备下次接收
 757   2                      debug_uart_print_string_int("code check error!\r\n");
 758   2                      EX0 = 1;                
 759   2              }       
 760   1              IE0 = 0;        
 761   1      }
 762          //小盒闭合的限位开关0中断服务程序(主要)
 763          void limit_switch0() interrupt 2
 764          {
 765   1              if(Box_status == STAT_BOX_CLOSING)
 766   1              {
 767   2                      box_close_finish();
 768   2              }
 769   1              IR_recovery_factory_mode(&IR_info);
 770   1              //debug_uart_print_string_int("limit switch [0] is trigered!\r\n");
 771   1              IE1 = 0;
 772   1      }
 773          //小盒打开的限位开关1中断服务程序
 774          void limit_switch1() interrupt 10
 775          {
 776   1              if(Box_status == STAT_BOX_OPENING)
 777   1              {
 778   2                      box_open_finish();
 779   2              }
 780   1              debug_uart_print_string_int("limit switch [1] is trigered!\r\n");
 781   1      }
 782          //系统时钟中断服务
 783          void PCA_isr() interrupt 7 using 1
 784          {
 785   1          CCF0 = 0;                       //清中断标志
 786   1          CCAP0L = value;
 787   1          CCAP0H = value >> 8;            //更新比较值
 788   1          value += T100Hz;
 789   1              sys_clk_100HZ_flag = 1;
 790   1      }
 791          
 792          
 793          
 794          
 795          
C51 COMPILER V9.00   MAIN                                                                  09/20/2016 20:51:59 PAGE 14  

 796          
 797          /*void box_open_error(void)
 798          {
 799                  Motor_set_status(pMyMotor,MOTOR_STOP);
 800                  Box_status = STAT_BOX_OPEN_ERROR;       
 801                  debug_uart_print_string_int("box_open_error\r\n");
 802          }
 803          void box_close_error(void)
 804          {
 805                  Motor_set_status(pMyMotor,MOTOR_STOP);
 806                  Box_status = STAT_BOX_CLOSE_ERROR;
 807                  debug_uart_print_string_int("box_close_error\r\n");
 808          }                  */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2420    ----
   CONSTANT SIZE    =    716    ----
   XDATA SIZE       =     19    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     40      28
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
